\documentclass[12pt,a4paper]{report}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{parskip}
\usepackage{graphicx}

\geometry{margin=2.5cm}

% Configurazione hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    citecolor=blue
}

\title{
    \textbf{Tetraj} \\
    \large Progetto di Programmazione ad Oggetti (12 CFU)
}
\author{
    Patrizio Bertozzi \\
    patrizio.bertozzi@studio.unibo.it
}
\date{
    Università di Bologna \\
    Corso di Laurea in Ingegneria e Scienze Informatiche \\
    \vspace{0.5cm}
    Anno Accademico 2024/2025
}

\begin{document}

\maketitle
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

\chapter{Analisi}

\section{Descrizione e requisiti}

Tetraj è una riproduzione del videogioco Tetris~\cite{tetriswiki}. Il giocatore manipola forme geometriche chiamate tetromini (pezzi composti da quattro blocchi quadrati) che cadono dall'alto dell'area di gioco. L'obiettivo è posizionare i tetromini completando righe orizzontali senza lasciare spazi vuoti: le righe completate scompaiono e il giocatore guadagna punti. La partita termina quando i pezzi si accumulano fino a raggiungere la parte superiore dell'area di gioco.

I tetromini sono sette, identificati da una lettera che ne richiama la forma: I (linea di 4 blocchi), O (quadrato), T, S, Z, J e L. Ogni tetromino ha un colore distintivo. L'area di gioco ha dimensioni standard: 10 celle in larghezza e 20 in altezza.

\subsection{Requisiti funzionali}

\begin{itemize}[leftmargin=*]
    \item \textbf{Gestione dei tetromini}
    \begin{itemize}
        \item Supporto per tutti e sette i tetromini standard, ciascuno con il proprio colore
        \item Rotazione in senso orario e antiorario
        \item Caduta automatica con velocità crescente in base al livello
        \item Movimento orizzontale (sinistra/destra)
        \item Soft drop (discesa accelerata) e hard drop (caduta istantanea)
    \end{itemize}

    \item \textbf{Selezione dei pezzi}
    \begin{itemize}
        \item Due modalità di selezione: ``7-bag randomizer'' (moderna) dove i sette tetromini vengono mescolati e distribuiti ciclicamente, oppure selezione completamente casuale (classica) come nel Tetris originale
        \item Anteprima del prossimo pezzo in arrivo
    \end{itemize}

    \item \textbf{Hold}
    \begin{itemize}
        \item Possibilità di trattenere il pezzo corrente per usarlo successivamente
        \item La funzione hold è utilizzabile una sola volta per ogni pezzo che cade
    \end{itemize}

    \item \textbf{Ghost piece}
    \begin{itemize}
        \item Visualizzazione di un'ombra che indica dove atterrerà il tetromino corrente
    \end{itemize}

    \item \textbf{Wall kick}
    \begin{itemize}
        \item Spostamento automatico del pezzo in una posizione valida quando una rotazione causerebbe collisione
    \end{itemize}

    \item \textbf{Linee e punteggio}
    \begin{itemize}
        \item Eliminazione delle righe completamente piene
        \item Punteggio basato sul numero di righe eliminate simultaneamente
        \item Bonus significativo per il ``Tetris'' (4 righe contemporanee)
        \item Punti bonus per il soft drop proporzionali alla distanza percorsa
        \item Punti bonus per l'hard drop proporzionali alla distanza di caduta
    \end{itemize}

    \item \textbf{Livelli e velocità}
    \begin{itemize}
        \item Aumento del livello ogni 10 righe completate
        \item Due curve di velocità: valori predefiniti per livello (classica) oppure formula di crescita continua (moderna)
    \end{itemize}

    \item \textbf{Stati e controlli}
    \begin{itemize}
        \item Menu principale, partita in corso, game over
        \item Pausa durante il gioco
        \item Effetti sonori per le azioni principali
    \end{itemize}

    \item \textbf{Classifica}
    \begin{itemize}
        \item Memorizzazione dei 10 migliori punteggi ottenuti
        \item Richiesta del nickname al giocatore se il punteggio entra in classifica
        \item Persistenza della classifica
        \item Visualizzazione della classifica al termine della partita
    \end{itemize}
\end{itemize}

\subsection{Requisiti non funzionali}

\begin{itemize}[leftmargin=*]
    \item \textbf{Portabilità}
    \begin{itemize}
        \item Esecuzione su Windows, macOS e Linux
    \end{itemize}

    \item \textbf{Prestazioni}
    \begin{itemize}
        \item Frame rate fluido e costante
        \item Assenza di flickering durante il rendering
    \end{itemize}

    \item \textbf{Usabilità}
    \begin{itemize}
        \item Visualizzazione chiara di: area di gioco, pezzo corrente, prossimo pezzo, pezzo trattenuto, punteggio, livello, righe completate
    \end{itemize}
\end{itemize}

\section{Modello del Dominio}

Il dominio di Tetraj ruota attorno a poche entità fondamentali.

L'elemento centrale è il \textbf{tetromino}, una forma geometrica composta da quattro blocchi. Esistono sette tipi di tetromino (I, O, T, S, Z, J, L), ciascuno con una forma e un colore caratteristici~\cite{tetromino}. Ogni tetromino possiede una posizione nell'area di gioco e uno stato di rotazione. Un tetromino può muoversi orizzontalmente, cadere verso il basso e ruotare.

L'\textbf{area di gioco} è una griglia rettangolare (10 celle in larghezza e 20 in altezza) che contiene i blocchi dei tetromini già posizionati. L'area di gioco è responsabile di verificare se una posizione è valida (non fuori dai bordi, non sovrapposta ad altri blocchi), di accogliere i tetromini quando si depositano, e di rilevare e rimuovere le righe complete.

La \textbf{partita} rappresenta una sessione di gioco completa. Una partita tiene traccia del punteggio, del livello corrente, del numero di righe eliminate, e gestisce la successione dei tetromini: il pezzo corrente in caduta, il prossimo pezzo in attesa, e l'eventuale pezzo trattenuto (held). La partita determina quando il gioco termina, ovvero quando un nuovo tetromino non può essere posizionato in cima all'area di gioco.

La \textbf{strategia di selezione} determina quale sarà il prossimo tetromino. Le due modalità (classica e moderna) differiscono nel criterio di scelta ma condividono lo stesso ruolo: fornire il prossimo pezzo alla partita.

La \textbf{strategia di velocità} determina quanto rapidamente i tetromini cadono in base al livello corrente. Anche qui le due modalità (classica e moderna) differiscono nella formula di calcolo ma hanno lo stesso scopo.

La \textbf{classifica} mantiene l'elenco dei migliori punteggi ottenuti. Ogni voce della classifica è rappresentata da un \textbf{record} che associa un punteggio ad altre informazioni rilevanti (ad esempio la data). La classifica è ordinata in modo decrescente per punteggio e può avere un numero massimo di 10 voci.

Infine il \textbf{giocatore} interagisce con la partita attraverso comandi: spostare il pezzo, ruotarlo, farlo cadere rapidamente, metterlo in hold, mettere in pausa.

% Placeholder per lo schema UML
\vspace{1cm}
\noindent\textit{[Schema UML del dominio: da inserire]}

\chapter{Design}

\section{Architettura}

L'architettura di Tetraj segue il pattern architetturale \textbf{MVC} (Model-View-Controller)~\cite{mvc} combinato con una \textbf{macchina a stati finiti} (FSM)~\cite{fsm} per la gestione delle transizioni tra le diverse schermate del gioco.

Il coordinamento tra i componenti è affidato a un \textbf{Service Locator}~\cite{servicelocator} che funge da punto centralizzato per l'accesso ai servizi condivisi; crea e collega i componenti all'avvio, e li rilascia allo spegnimento.

Il \textbf{Game Loop}~\cite{gameloop} costituisce il cuore pulsante dell'applicazione: ad ogni iterazione interroga la macchina a stati per ottenere il controller attivo, ne aggiorna la logica e ne richiede il rendering.

La gestione dell'input è disaccoppiata dalla logica di gioco tramite il pattern \textbf{Command}~\cite{command}: un gestore di input mappa i tasti a comandi, permettendo configurazioni diverse per ogni stato senza modificare la logica dei controller.

Ogni schermata del gioco ha il proprio trittico MVC, composto dal \textbf{Model} (\texttt{PlayModel}, \texttt{MenuModel}, ecc.) contenente lo stato e la logica di dominio, dalla \textbf{View} (\texttt{PlayView}, \texttt{MenuView}, ecc.) che è responsabile esclusivamente del rendering ed estende una classe base comune per la gestione delle risorse grafiche, e infine dal \textbf{Controller} (\texttt{PlayController}, \texttt{MenuController}, ecc.) che implementa l'interfaccia \texttt{Controller} definendo il ciclo di vita (\texttt{enter}, \texttt{exit}), l'aggiornamento (\texttt{update}), il rendering (\texttt{render}), la gestione dell'input (\texttt{handleInput}, \texttt{handleInputRelease}) e l'esposizione del componente grafico (\texttt{getCanvas}) che il Game Loop monta nella finestra principale. Ogni controller possiede il proprio Model e la propria View, coordinandone l'interazione.

Con questa architettura, aggiungere una nuova schermata al gioco richiede di creare una nuova terna MVC, registrare il nuovo stato nella macchina a stati e aggiungere il controller al Service Locator. Il Game Loop non necessita di alcuna modifica, garantendo un'estensione modulare del sistema senza impatti sulle componenti esistenti.

L'architettura garantisce inoltre la completa sostituibilità della View senza impatti su Controller e Model. Le View non mantengono riferimenti al Model, ricevendolo solo come parametro per il rendering, e i Controller interagiscono con esse esclusivamente tramite l'interfaccia comune. I Model sono completamente agnostici rispetto alla tecnologia grafica. Per transitare ad una diversa libreria grafica sarebbe sufficiente reimplementare le classi View e adattare la gestione della finestra nel Game Loop; Controller e Model rimarrebbero invariati.

% Placeholder per lo schema UML architetturale
\vspace{1cm}
\noindent\textit{[Schema UML architetturale: da inserire]}

\section{Design dettagliato}

\subsection{Selezione dei pezzi}

\textbf{Problema}

Il gioco deve supportare diverse modalità di selezione del prossimo tetromino. La versione classica di Tetris usa una selezione puramente casuale, mentre le versioni moderne adottano il sistema ``7-bag randomizer'' che garantisce una distribuzione equa dei pezzi. La scelta della modalità deve essere configurabile senza modificare il codice.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{resources/piece-selection.png}
    \caption{Diagramma UML del pattern Strategy per la selezione dei pezzi}
    \label{fig:piece-selection}
\end{figure}

\textbf{Soluzione}

Come da Figura~\ref{fig:piece-selection} si è adottata una combinazione di \textbf{Strategy}~\cite{strategy} e \textbf{Simple Factory}~\cite{simplefactory}. L'interfaccia \texttt{PieceSelectionStrategy} definisce il contratto per la selezione (\texttt{next()} restituisce il prossimo tipo di tetromino, \texttt{reset()} reinizializza lo stato), mentre le implementazioni concrete (\texttt{RandomStrategy}, \texttt{BagRandomizerStrategy}) incapsulano i diversi algoritmi. Infine \texttt{PieceSelectionFactory}, in \texttt{create()}, legge la configurazione e istanzia la strategia appropriata.

La soluzione risulta estensibile (nuove strategie senza modificare codice esistente), testabile (strategie isolabili), e configurabile a runtime. Al contrario di alternative basate su If/Else/Switch-case o con l'utilizzo di Enum.

\subsection{Rendering delle View}

\textbf{Problema}

Le diverse schermate del gioco (menu, partita, game over, classifica) condividono la stessa logica di inizializzazione del canvas e del buffer strategy, ma differiscono nel contenuto da disegnare. Duplicare questa logica in ogni view violerebbe il principio DRY e renderebbe difficile la manutenzione.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{resources/abstract-view.png}
    \caption{Diagramma UML del pattern Template Method per il rendering delle View}
    \label{fig:abstract-view}
\end{figure}

\textbf{Soluzione}

Come da Figura~\ref{fig:abstract-view} si è adottato il pattern \textbf{Template Method}~\cite{templatemethod}. \texttt{AbstractView<M>} definisce il metodo template \texttt{render(M model)} che gestisce l'inizializzazione del buffer strategy per poi delegare a \texttt{renderContent(M model)}. Le sottoclassi (\texttt{PlayView}, \texttt{MenuView}, \texttt{GameOverView}, \texttt{LeaderboardView}) implementano solo \texttt{renderContent()} con la propria logica di disegno; la classe base fornisce anche getter protetti per risorse comuni (font, dimensioni, colori).

La soluzione elimina duplicazione e garantisce un'inizializzazione corretta e consistente, lasciando le sottoclassi focalizzate solo sul proprio disegno. Rispetto a una soluzione basata su composizione, risulta meno flessibile in scenari più complessi.

\subsection{Tetromini: gerarchia e creazione}

\textbf{Problema}

I sette tetromini condividono comportamenti comuni (movimento, rotazione, posizione) ma differiscono per forma, colore e stati di rotazione. Serve una struttura che eviti duplicazione, garantisca copie type-safe, centralizzi la creazione e permetta estensioni future.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{resources/tetromino.png}
    \caption{Diagramma UML della gerarchia dei tetromini e del sistema di creazione (per semplicità sono mostrati solo 3 dei 7 tetromini)}
    \label{fig:tetromino}
\end{figure}

\textbf{Soluzione}

Come da Figura~\ref{fig:tetromino} si è strutturata una gerarchia a tre livelli combinata con un sistema di creazione centralizzato.

L'interfaccia \texttt{Tetromino} definisce il contratto pubblico. La classe astratta \texttt{AbstractTetromino<T extends AbstractTetromino<T>{>}} implementa i comportamenti comuni usando \textbf{F-bounded Polymorphism}~\cite{fbounded}: il parametro di tipo ricorsivo garantisce che \texttt{copy()} restituisca il tipo concreto invece di un generico \texttt{Tetromino}. I tetromini concreti (\texttt{ITetromino}, \texttt{OTetromino}, \texttt{TTetromino}, ecc.) estendono la classe astratta implementando solo i metodi specifici: \texttt{getShapes()}, \texttt{getColor()}, \texttt{copy()}.

Per la creazione, \texttt{TetrominoRegistry} implementa il pattern \textbf{Registry}~\cite{registry} (come \textbf{Singleton}~\cite{singleton}) mantenendo una mappa che associa ogni classe di tetromino alla sua funzione di creazione. \texttt{TetrominoFactory} usa la strategia di selezione per ottenere il tipo da creare e delega al registry per l'inizializzazione effettiva.

La soluzione garantisce type-safety a compile-time, codice DRY ed estensibilità: aggiungere un nuovo tetromino richiede solo di creare la classe e registrarla. Al contrario, alternative senza generici avrebbero richiesto cast espliciti, mentre uno Switch-case sulla classe avrebbe violato l'Open/Closed Principle.

\chapter{Sviluppo}

\section{Testing automatizzato}

Il progetto utilizza diverse librerie per garantire la qualità del codice attraverso test automatizzati:

\begin{itemize}
    \item \textbf{JUnit 5}: framework principale per la scrittura e l'esecuzione dei test unitari.
    \item \textbf{JUnit Jupiter Params}: estensione di JUnit per la creazione di test parametrizzati, che consente di eseguire lo stesso test con diversi input riducendo la duplicazione del codice.
    \item \textbf{Mockito}: libreria per la creazione di mock objects, utilizzata per isolare le unità sotto test dalle loro dipendenze.
    \item \textbf{JaCoCo}: strumento per la misurazione della code coverage, integrato nel processo di build per generare report sulla percentuale di codice effettivamente esercitata dai test.
\end{itemize}

I test si concentrano sulle componenti che contengono la logica di gioco più critica e sulle classi che orchestrano il comportamento di altre entità.

Il cuore del testing riguarda il \textbf{model}: i tetromini vengono verificati nella loro creazione, rotazione e posizionamento, con test parametrizzati che coprono tutti e sette i tipi di pezzi. La \textbf{Board} è testata per la validazione delle posizioni, il rilevamento delle collisioni e l'eliminazione delle righe complete. Le strategie di selezione dei pezzi sono verificate nelle loro invarianti --- ad esempio, che il bag randomizer distribuisca tutti i pezzi prima di ripetere.

Per quanto riguarda la \textbf{persistenza}, la \textbf{Leaderboard} è testata sia nella logica di ordinamento e limite delle voci, sia nel funzionamento dei diversi provider di storage (JSON su file e Redis), utilizzando Mockito per isolare i test dalle dipendenze esterne.

Infine le classi \textbf{GameStateManager} e \textbf{GameSession} sono testate per verificare le transizioni tra gli stati del gioco e la corretta gestione del ciclo di vita della partita.

\appendix

\chapter{Guida utente}

\section{Avvio del gioco}

Per avviare Tetraj è necessario avere Java 21 (o versione successiva)~\cite{adoptium} installato sul proprio sistema. Il gioco si avvia eseguendo il file \texttt{tetraj.jar} con il comando:

\begin{verbatim}
java -jar tetraj.jar
\end{verbatim}

\section{Schermata iniziale}

All'avvio viene mostrato il menu principale. Da qui è possibile:

\begin{itemize}
    \item Premere \textbf{INVIO} per iniziare una nuova partita
    \item Premere \textbf{L} per visualizzare la classifica dei punteggi
    \item Premere \textbf{ESC} per uscire dal gioco
\end{itemize}

\section{Durante la partita}

Una volta avviata la partita, sullo schermo sono visibili: l'area di gioco centrale dove cadono i pezzi, il prossimo pezzo in arrivo, l'eventuale pezzo messo da parte, il punteggio, il livello e il numero di linee completate.

I controlli disponibili sono:

\begin{itemize}
    \item \textbf{Freccia sinistra} o \textbf{A}: sposta il pezzo a sinistra
    \item \textbf{Freccia destra} o \textbf{D}: sposta il pezzo a destra
    \item \textbf{Freccia giù} o \textbf{S}: accelera la caduta del pezzo (soft drop)
    \item \textbf{Barra spaziatrice}: fa cadere istantaneamente il pezzo (hard drop)
    \item \textbf{Freccia su} o \textbf{W}: ruota il pezzo in senso orario
    \item \textbf{CTRL} o \textbf{Z}: ruota il pezzo in senso antiorario
    \item \textbf{SHIFT} o \textbf{C}: mette da parte il pezzo corrente per usarlo dopo
    \item \textbf{P}: mette in pausa la partita
    \item \textbf{ESC}: torna al menu principale
\end{itemize}

Durante la pausa, premere \textbf{P} o \textbf{ESC} per riprendere a giocare.

\section{Punteggio}

Il punteggio aumenta completando linee orizzontali. Più linee si completano contemporaneamente, più punti si ottengono:

\begin{itemize}
    \item 1 linea: 100 punti
    \item 2 linee: 300 punti
    \item 3 linee: 500 punti
    \item 4 linee (Tetris): 800 punti
\end{itemize}

I punti vengono moltiplicati per il livello corrente. Inoltre, il soft drop assegna 1 punto bonus per ogni cella percorsa, mentre l'hard drop ne assegna 2 per ogni cella di altezza da cui cade il pezzo.

Il livello aumenta ogni 10 linee completate, rendendo la caduta dei pezzi progressivamente più veloce.

\section{Fine partita e classifica}

La partita termina quando non c'è più spazio per posizionare un nuovo pezzo. Viene mostrata la schermata di fine partita con il punteggio ottenuto. Da qui è possibile:

\begin{itemize}
    \item Premere \textbf{INVIO} per iniziare una nuova partita
    \item Premere \textbf{L} per visualizzare la classifica
    \item Premere \textbf{ESC} per tornare al menu principale
\end{itemize}

Dalla schermata della classifica, premere \textbf{ESC} per tornare al menu.

\chapter{Esercitazioni di laboratorio}

\section*{patrizio.bertozzi@studio.unibo.it}

\begin{itemize}
    \item Laboratorio 07: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=177162#p246015}
    \item Laboratorio 09: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=179154#p247849}
    \item Laboratorio 10: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=180101#p248934}
    \item Laboratorio 11: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=181206#p251421}
\end{itemize}

\begin{thebibliography}{99}

\bibitem{tetriswiki}
TetrisWiki,
\textit{Tetris Wiki -- Enciclopedia della community dedicata al gioco Tetris},
\url{https://tetris.wiki/Tetris.wiki}

\bibitem{tetromino}
TetrisWiki,
\textit{Tetromino -- Descrizione delle forme e dei colori ufficiali dei sette tetromini},
\url{https://tetris.wiki/Tetromino}

\bibitem{mvc}
Wikipedia,
\textit{Model--view--controller},
\url{https://en.wikipedia.org/wiki/Model-view-controller}

\bibitem{fsm}
Wikipedia,
\textit{Finite-state machine},
\url{https://en.wikipedia.org/wiki/Finite-state_machine}

\bibitem{servicelocator}
Wikipedia,
\textit{Service locator pattern},
\url{https://en.wikipedia.org/wiki/Service_locator_pattern}

\bibitem{gameloop}
Wikipedia,
\textit{Game loop},
\url{https://en.wikipedia.org/wiki/Game_loop}

\bibitem{command}
Wikipedia,
\textit{Command pattern},
\url{https://en.wikipedia.org/wiki/Command_pattern}

\bibitem{strategy}
Wikipedia,
\textit{Strategy pattern},
\url{https://en.wikipedia.org/wiki/Strategy_pattern}

\bibitem{simplefactory}
Wikipedia,
\textit{Factory (object-oriented programming)},
\url{https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)}

\bibitem{templatemethod}
Wikipedia,
\textit{Template method pattern},
\url{https://en.wikipedia.org/wiki/Template_method_pattern}

\bibitem{fbounded}
Wikipedia,
\textit{Bounded quantification -- F-bounded quantification},
\url{https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification}

\bibitem{registry}
Martin Fowler,
\textit{Registry},
\url{https://martinfowler.com/eaaCatalog/registry.html}

\bibitem{singleton}
Wikipedia,
\textit{Singleton pattern},
\url{https://en.wikipedia.org/wiki/Singleton_pattern}

\bibitem{adoptium}
Eclipse Adoptium,
\textit{Temurin JDK 21 -- Pagina di download},
\url{https://adoptium.net/temurin/releases?version=21}

\end{thebibliography}

\end{document}
