\documentclass[12pt,a4paper]{report}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{parskip}
\usepackage{graphicx}
\usepackage{float}
\usepackage{xurl}
\usepackage{listings}

\geometry{margin=2.5cm}

% Configurazione hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    citecolor=blue
}

\title{
    \textbf{Tetraj} \\
    \large Progetto di Programmazione ad Oggetti (12 CFU)
}
\author{
    Patrizio Bertozzi \\
    patrizio.bertozzi@studio.unibo.it
}
\date{
    Università di Bologna \\
    Corso di Laurea in Ingegneria e Scienze Informatiche \\
    \vspace{0.5cm}
    Anno Accademico 2024/2025
}

\begin{document}

\maketitle
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

\chapter{Analisi}

\section{Descrizione e requisiti}

Tetraj è una riproduzione del videogioco Tetris~\cite{tetriswiki}. Il giocatore manipola forme geometriche chiamate tetromini (pezzi composti da quattro blocchi quadrati) che cadono dall'alto dell'area di gioco. L'obiettivo è posizionare i tetromini completando linee orizzontali senza lasciare spazi vuoti: le linee completate scompaiono e il giocatore guadagna punti. La partita termina quando i pezzi si accumulano fino a raggiungere la parte superiore dell'area di gioco.

I tetromini sono sette, identificati da una lettera che ne richiama la forma: I (linea di 4 blocchi), O (quadrato), T, S, Z, J e L. Ogni tetromino ha un colore distintivo. L'area di gioco ha dimensioni standard: 10 celle in larghezza e 20 in altezza.

\subsection{Requisiti funzionali}

\begin{itemize}[leftmargin=*]
    \item \textbf{Gestione dei tetromini}
    \begin{itemize}
        \item Supporto per tutti e sette i tetromini standard, ciascuno con il proprio colore
        \item Rotazione in senso orario e antiorario
        \item Caduta automatica con velocità crescente in base al livello
        \item Movimento orizzontale, a sinistra e a destra
        \item Soft drop (discesa accelerata) e hard drop (caduta istantanea)
    \end{itemize}

    \item \textbf{Selezione dei pezzi}
    \begin{itemize}
        \item Due modalità di selezione: ``7-bag randomizer'' (moderna) dove i sette tetromini vengono mescolati e distribuiti ciclicamente, oppure selezione completamente casuale (classica) come nel Tetris originale
        \item Anteprima del prossimo pezzo in arrivo
    \end{itemize}

    \item \textbf{Hold}
    \begin{itemize}
        \item Possibilità di trattenere il pezzo corrente per usarlo successivamente
        \item La funzione hold è utilizzabile una sola volta per ogni pezzo che cade
    \end{itemize}

    \item \textbf{Ghost piece}
    \begin{itemize}
        \item Visualizzazione di un'ombra che indica dove atterrerà il tetromino corrente
    \end{itemize}

    \item \textbf{Wall kick}
    \begin{itemize}
        \item Spostamento automatico del pezzo in una posizione valida quando una rotazione causerebbe collisione
    \end{itemize}

    \item \textbf{Linee e punteggio}
    \begin{itemize}
        \item Eliminazione delle linee completamente piene
        \item Punteggio basato sul numero di linee eliminate simultaneamente
        \item Bonus significativo per il ``Tetris'' (4 linee contemporanee)
        \item Punti bonus per il soft drop proporzionali alla distanza percorsa
        \item Punti bonus per l'hard drop proporzionali alla distanza di caduta
    \end{itemize}

    \item \textbf{Livelli e velocità}
    \begin{itemize}
        \item Aumento del livello ogni 10 linee completate
        \item Due curve di velocità: valori predefiniti per livello (classica) oppure formula di crescita continua (moderna)
    \end{itemize}

    \item \textbf{Stati e controlli}
    \begin{itemize}
        \item Menu principale, partita in corso, game over
        \item Pausa durante il gioco
        \item Effetti sonori per le azioni principali
    \end{itemize}

    \item \textbf{Classifica}
    \begin{itemize}
        \item Memorizzazione dei 10 migliori punteggi ottenuti
        \item Richiesta del nickname al giocatore se il punteggio entra in classifica
        \item Persistenza della classifica
        \item Visualizzazione della classifica al termine della partita
    \end{itemize}
\end{itemize}

\subsection{Requisiti non funzionali}

\begin{itemize}[leftmargin=*]
    \item \textbf{Portabilità}
    \begin{itemize}
        \item Esecuzione su Windows, macOS e Linux
    \end{itemize}

    \item \textbf{Prestazioni}
    \begin{itemize}
        \item Frame rate fluido e costante
        \item Assenza di flickering durante il rendering
    \end{itemize}

    \item \textbf{Usabilità}
    \begin{itemize}
        \item Visualizzazione chiara di: area di gioco, pezzo corrente, prossimo pezzo, pezzo trattenuto, punteggio, livello, linee completate
    \end{itemize}
\end{itemize}

\section{Modello del Dominio}

Il dominio di Tetraj ruota attorno a poche entità fondamentali.

L'elemento centrale è il \textbf{tetromino}, una forma geometrica composta da quattro blocchi. Esistono sette tipi di tetromino (I, O, T, S, Z, J, L), ciascuno con una forma e un colore caratteristici~\cite{tetromino}. Ogni tetromino possiede una posizione nell'area di gioco e uno stato di rotazione. Un tetromino può muoversi orizzontalmente, cadere verso il basso e ruotare.

L'\textbf{area di gioco} è una griglia rettangolare (10 celle in larghezza e 20 in altezza) che contiene i blocchi dei tetromini già posizionati. L'area di gioco ha la responsabilità di verificare se una posizione è valida (non fuori dai bordi, non sovrapposta ad altri blocchi), di accogliere i tetromini quando si depositano, e di rilevare e rimuovere le linee complete.

La \textbf{partita} rappresenta una sessione di gioco completa. Una partita tiene traccia del punteggio, del livello corrente, del numero di linee eliminate, e gestisce la successione dei tetromini: il pezzo corrente in caduta, il prossimo pezzo in attesa, e l'eventuale pezzo trattenuto. La partita determina quando il gioco termina, ovvero quando un nuovo tetromino non può essere posizionato in cima all'area di gioco.

La \textbf{strategia di selezione} determina quale sarà il prossimo tetromino. Le due modalità (classica e moderna) differiscono nel criterio di scelta ma condividono lo stesso ruolo: fornire il prossimo pezzo alla partita.

La \textbf{strategia di velocità} determina quanto rapidamente i tetromini cadono in base al livello corrente. Anche qui le due modalità (classica e moderna) differiscono nella formula di calcolo ma hanno lo stesso scopo.

La \textbf{classifica} mantiene l'elenco dei migliori punteggi ottenuti. Ogni voce della classifica è rappresentata da un \textbf{elemento} che associa un punteggio ad altre informazioni rilevanti (ad esempio la data). La classifica è ordinata in modo decrescente per punteggio e può avere un numero massimo di 10 voci. La classifica deve essere persistente tra le sessioni di gioco, delegando la memorizzazione a un sistema di storage esterno. Al termine di una partita, se il punteggio ottenuto è sufficientemente alto, il giocatore può inserire il proprio record in classifica.

Infine il \textbf{giocatore} interagisce con la partita attraverso comandi: spostare il pezzo, ruotarlo, farlo cadere rapidamente, metterlo in hold, mettere in pausa.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{resources/game-model.png}
    \caption{Schema UML dell'analisi del problema, con rappresentate le entità principali ed i rapporti fra loro}
    \label{fig:domain-model}
\end{figure}

\chapter{Design}

\section{Architettura}

L'architettura di Tetraj segue il pattern architetturale \textbf{MVC} (Model-View-Controller)~\cite{mvc} combinato con una \textbf{macchina a stati finiti} (FSM)~\cite{fsm} per la gestione delle transizioni tra le diverse schermate del gioco.

Il coordinamento tra i componenti è affidato a un \textbf{Service Locator}~\cite{servicelocator} che funge da punto centralizzato per l'accesso ai servizi condivisi; crea e collega i componenti all'avvio, e li rilascia allo spegnimento.

Il \textbf{Game Loop}~\cite{gameloop} costituisce il cuore pulsante dell'applicazione: ad ogni iterazione interroga la macchina a stati per ottenere il controller attivo, ne aggiorna la logica e ne richiede il rendering.

La gestione dell'input è disaccoppiata dalla logica di gioco tramite il pattern \textbf{Command}~\cite{command}: un gestore di input mappa i tasti a comandi, permettendo configurazioni diverse per ogni stato senza modificare la logica dei controller.

Ogni schermata del gioco ha il proprio trittico MVC, composto dal \textbf{Model} (\texttt{PlayModel}, \texttt{MenuModel}, ecc.) contenente lo stato e la logica di dominio, dalla \textbf{View} (\texttt{PlayView}, \texttt{MenuView}, ecc.) che è responsabile esclusivamente del rendering ed estende una classe base comune per la gestione delle risorse grafiche, e infine dal \textbf{Controller} (\texttt{PlayController}, \texttt{MenuController}, ecc.) che implementa l'interfaccia \texttt{Controller} definendo il ciclo di vita (\texttt{enter}, \texttt{exit}), l'aggiornamento (\texttt{update}), il rendering (\texttt{render}), la gestione dell'input (\texttt{handleInput}, \texttt{handleInputRelease}) e l'esposizione del componente grafico (\texttt{getCanvas}) che il Game Loop monta nella finestra principale. Ogni controller possiede il proprio Model e la propria View, coordinandone l'interazione.

Con questa architettura, aggiungere una nuova schermata al gioco richiede di creare una nuova terna MVC, registrare il nuovo stato nella macchina a stati e aggiungere il controller al Service Locator. Il Game Loop non necessita di alcuna modifica, garantendo un'estensione modulare del sistema senza impatti sulle componenti esistenti.

L'architettura garantisce inoltre la completa sostituibilità della View senza impatti su Controller e Model. Le View non mantengono riferimenti al Model, ricevendolo solo come parametro per il rendering, e i Controller interagiscono con esse esclusivamente tramite l'interfaccia comune. I Model sono completamente agnostici rispetto alla tecnologia grafica. Per transitare ad una diversa libreria grafica sarebbe sufficiente reimplementare le classi View e adattare la gestione della finestra nel Game Loop; Controller e Model rimarrebbero invariati.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{resources/architecture.png}
    \caption{Diagramma UML dell'architettura del sistema}
    \label{fig:architecture}
\end{figure}

\section{Design dettagliato}

\subsection{Selezione dei pezzi}

\textbf{Problema}

Il gioco deve supportare diverse modalità di selezione del prossimo tetromino. La versione classica di Tetris usa una selezione puramente casuale, mentre le versioni moderne adottano il sistema ``7-bag randomizer'' che garantisce una distribuzione equa dei pezzi. La scelta della modalità deve essere configurabile senza modificare il codice.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{resources/piece-selection.png}
    \caption{Diagramma UML del pattern Strategy per la selezione dei pezzi}
    \label{fig:piece-selection}
\end{figure}

\textbf{Soluzione}

Come da Figura~\ref{fig:piece-selection} si è adottata una combinazione di \textbf{Strategy}~\cite{strategy} e \textbf{Simple Factory}~\cite{simplefactory}. L'interfaccia \texttt{PieceSelectionStrategy} definisce il contratto per la selezione: \texttt{next()} restituisce il prossimo tipo di tetromino, \texttt{reset()} reinizializza lo stato. Mentre le implementazioni concrete (\texttt{RandomStrategy}, \texttt{BagRandomizerStrategy}) incapsulano i diversi algoritmi. Infine \texttt{PieceSelectionFactory}, in \texttt{create()}, legge la configurazione e istanzia la strategia appropriata.

La soluzione risulta estensibile (è possibile inserire nuove strategie senza modificare codice esistente), testabile (strategie isolabili), e configurabile a runtime. Al contrario di alternative basate su If/Else/Switch-case o con l'utilizzo di enum.

\subsection{Rendering delle View}

\textbf{Problema}

Le diverse schermate del gioco (menu, partita, game over, classifica) condividono la stessa logica di inizializzazione del canvas e del buffer strategy, ma differiscono nel contenuto da disegnare. Duplicare questa logica in ogni view violerebbe il principio DRY e renderebbe difficile la manutenzione.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{resources/abstract-view.png}
    \caption{Diagramma UML del pattern Template Method per il rendering delle View}
    \label{fig:abstract-view}
\end{figure}

\textbf{Soluzione}

Come da Figura~\ref{fig:abstract-view} si è adottato il pattern \textbf{Template Method}~\cite{templatemethod}. \texttt{AbstractView<M>} definisce il metodo template \texttt{render(M model)} che gestisce l'inizializzazione del buffer strategy per poi delegare a \texttt{renderContent(Graphics2D g, M model)}. Le sottoclassi (\texttt{PlayView}, \texttt{MenuView}, \texttt{GameOverView}, \texttt{LeaderboardView}) implementano solo \texttt{renderContent(Graphics2D g, M model)} con la propria logica di disegno; la classe base fornisce anche getter protetti per risorse comuni (font, dimensioni, colori).

La soluzione elimina duplicazione e garantisce un'inizializzazione corretta e consistente, lasciando le sottoclassi focalizzate solo sul proprio disegno. Rispetto a una soluzione basata su composizione, risulta meno flessibile in scenari più complessi.

\subsection{Tetromini: gerarchia e creazione}

\textbf{Problema}

I sette tetromini condividono comportamenti comuni (movimento, rotazione, posizione) ma differiscono per forma, colore e stati di rotazione. Serve una struttura che eviti duplicazione, garantisca copie type-safe, centralizzi la creazione e permetta estensioni future.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{resources/tetromino.png}
    \caption{Diagramma UML della gerarchia dei tetromini e del sistema di creazione (per semplicità sono mostrati solo 3 dei 7 tetromini)}
    \label{fig:tetromino}
\end{figure}

\textbf{Soluzione}

Come da Figura~\ref{fig:tetromino} si è strutturata una gerarchia a tre livelli combinata con un sistema di creazione centralizzato.

L'interfaccia \texttt{Tetromino} definisce il contratto pubblico. La classe astratta \texttt{AbstractTetromino<T extends AbstractTetromino<T>{>}} implementa i comportamenti comuni usando \textbf{F-bounded Polymorphism}~\cite{fbounded}: il parametro di tipo ricorsivo garantisce che \texttt{copy()} restituisca il tipo concreto invece di un generico \texttt{Tetromino}. I tetromini concreti (\texttt{ITetromino}, \texttt{OTetromino}, \texttt{TTetromino}, ecc.) estendono la classe astratta implementando solo i metodi specifici: \texttt{getShapes()}, \texttt{getColor()}, \texttt{copy()}.

Per la creazione, \texttt{TetrominoRegistry} implementa il pattern \textbf{Registry}~\cite{registry} (come \textbf{Singleton}~\cite{singleton}) mantenendo una mappa che associa ogni classe di tetromino alla sua funzione di creazione. \texttt{TetrominoFactory} usa la strategia di selezione per ottenere il tipo da creare e delega al registry per l'inizializzazione effettiva.

La soluzione garantisce type-safety a compile-time, codice DRY ed estensibilità: aggiungere un nuovo tetromino richiede solo di creare la classe e registrarla. Al contrario, alternative senza generici avrebbero richiesto cast espliciti, mentre uno Switch-case sulla classe avrebbe violato l'Open/Closed Principle.

\subsection{Gestione degli stati di gioco}

\textbf{Problema}

Il gioco è composto da più schermate (menu principale, partita, game over, classifica) con transizioni vincolate: ad esempio, dalla partita si può passare solo a game over o al menu, mai direttamente alla classifica. È necessario gestire queste transizioni in modo centralizzato, validandole per evitare stati incoerenti, e propagare le informazioni rilevanti da uno stato al successivo senza accoppiare i controller tra loro.

\begin{figure}[H]
    \centering
    \includegraphics[height=0.6\textwidth]{resources/fsm-states.png}
    \caption{Diagramma degli stati e delle transizioni valide nel gioco}
    \label{fig:fsm-states}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.95\textwidth]{resources/fsm.png}
    \caption{Diagramma UML della macchina a stati finiti per la gestione delle schermate}
    \label{fig:fsm}
\end{figure}

\textbf{Soluzione}

Come da Figura~\ref{fig:fsm-states} e Figura~\ref{fig:fsm}, si è adottata una \textbf{macchina a stati finiti} (FSM)~\cite{fsm} per governare le transizioni tra le schermate. La classe \texttt{GameStateManager} mantiene lo stato corrente tramite l'enum \texttt{GameState} e una mappa di transizioni valide (\texttt{EnumMap<GameState, Set<GameState>{>}}) inizializzata nel costruttore. Il metodo \texttt{switchTo(GameState)} verifica la validità della transizione prima di effettuarla: se non è valida, la rifiuta e logga un warning; altrimenti invoca \texttt{exit()} sul controller uscente --- che restituisce una \texttt{GameSession} con i dati della partita --- e \texttt{enter(GameSession)} sul controller entrante, propagando il contesto senza che i due controller si conoscano.

\texttt{GameSession} è un oggetto immutabile (con copie difensive per le immagini) che funge da \textbf{data transfer object} (DTO) tra gli stati: contiene punteggio, livello, linee completate, ultimo frame renderizzato e tempi di gioco. L'uso di un Builder semplifica la costruzione nelle varie transizioni. Il \texttt{GameEngine}, nel game loop, interroga il \texttt{GameStateManager} per rilevare cambiamenti di stato e aggiornare il canvas nella finestra.

Questa soluzione centralizza la logica di transizione in un unico punto, rendendo impossibili transizioni non previste e disaccoppiando completamente i controller tra loro. Aggiungere un nuovo stato richiede solo di estendere l'enum, definire le transizioni valide e registrare il controller associato, senza modificare il \texttt{GameEngine} né gli altri controller.

\chapter{Sviluppo}

\section{Testing automatizzato}

Il progetto utilizza diverse librerie per garantire la qualità del codice attraverso test automatizzati:

\begin{itemize}
    \item \textbf{JUnit 5}: framework principale per la scrittura e l'esecuzione dei test unitari.
    \item \textbf{JUnit Jupiter Params}: estensione di JUnit per la creazione di test parametrizzati, che consente di eseguire lo stesso test con diversi input riducendo la duplicazione del codice.
    \item \textbf{Mockito}: libreria per la creazione di mock objects, utilizzata per isolare le unità sotto test dalle loro dipendenze.
    \item \textbf{JaCoCo}: strumento per la misurazione della code coverage, integrato nel processo di build per generare report sulla percentuale di codice effettivamente esercitata dai test.
\end{itemize}

I test si concentrano sulle componenti che contengono la logica di gioco più critica e sulle classi che orchestrano il comportamento di altre entità.

Il cuore del testing riguarda il \textbf{model}: i tetromini vengono verificati nella loro creazione, rotazione e posizionamento, con test parametrizzati che coprono tutti e sette i tipi di pezzi. La \textbf{Board} è testata per la validazione delle posizioni, il rilevamento delle collisioni e l'eliminazione delle linee complete. Le strategie di selezione dei pezzi sono verificate nelle loro invarianti --- ad esempio, che il bag randomizer distribuisca tutti i pezzi prima di ripetere.

Per quanto riguarda la \textbf{persistenza}, la \textbf{Leaderboard} è testata sia nella logica di ordinamento e limite delle voci, sia nel funzionamento dei diversi provider di storage (JSON su file e Redis), utilizzando Mockito per isolare i test dalle dipendenze esterne.

Infine le classi \textbf{GameStateManager} e \textbf{GameSession} sono testate per verificare le transizioni tra gli stati del gioco e la corretta gestione del ciclo di vita della partita.

\section{Note di sviluppo}

\textbf{Utilizzo di Log4j2 per il logging}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/main/java/it/unibo/tetraj/GameStateManager.java#L17}

\textbf{Utilizzo di Jackson per serializzazione e deserializzazione JSON}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/main/java/it/unibo/tetraj/model/leaderboard/JsonFileStorageProvider.java#L119-L146}

\textbf{Utilizzo di Jedis per connessione a Redis}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/main/java/it/unibo/tetraj/model/leaderboard/RedisStorageProvider.java#L70-L92}

\textbf{Utilizzo di JUnit 5 con test parametrizzati (@MethodSource)}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/test/java/it/unibo/tetraj/model/piece/TetrominoTest.java#L201}

\textbf{Utilizzo di JUnit 5 con test parametrizzati (@CsvSource)}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/test/java/it/unibo/tetraj/model/PlayModelTest.java#L661}

\textbf{Utilizzo di Mockito per mock objects}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/test/java/it/unibo/tetraj/model/leaderboard/RedisStorageProviderTest.java#L51-L69}

\textbf{F-bounded polymorphism per copie type-safe}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/main/java/it/unibo/tetraj/model/piece/AbstractTetromino.java#L10}

\textbf{Strutture generiche complesse innestate}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/main/java/it/unibo/tetraj/model/piece/TetrominoRegistry.java#L14-L16}

\textbf{TypeReference di Jackson per preservare tipi generici a runtime}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/main/java/it/unibo/tetraj/model/leaderboard/JsonFileStorageProvider.java#L33-L36}

\textbf{Inizializzazione lazy thread-safe con ConcurrentHashMap.computeIfAbsent()}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/main/java/it/unibo/tetraj/util/LoggerFactory.java#L50}

\textbf{Shutdown hook con watchdog thread per cleanup risorse}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/main/java/it/unibo/tetraj/ApplicationContext.java#L176-L201}

\textbf{Utilizzo di lambda expressions}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/main/java/it/unibo/tetraj/model/piece/TetrominoRegistry.java#L20-L31}

\textbf{Utilizzo di method references}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/main/java/it/unibo/tetraj/model/PlayModel.java#L189}

\textbf{Utilizzo di Stream}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/main/java/it/unibo/tetraj/model/leaderboard/RedisStorageProvider.java#L175-L179}

\textbf{Chaining null-safe con Optional}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/main/java/it/unibo/tetraj/model/PlayModel.java#L240}

\textbf{Utilizzo di functional interfaces (Consumer, BiFunction, Runnable) come parametri}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/main/java/it/unibo/tetraj/model/PlayModel.java#L325-L338}

\textbf{Costruzione di oggetti immutabili complessi}\\
Permalink: \url{https://github.com/xpicio/OOP24-tetraj/blob/273676fb34af5e40427604d965e7eca11c81e7b8/src/main/java/it/unibo/tetraj/controller/PlayController.java#L61-L69}

\subsubsection{Codice riadattato}

Un aspetto che sicuramente ha semplificato notevolmente la gestione dei pezzi e del wall kick è stato l'utilizzo di matrici tridimensionali con stati di rotazione pre-calcolati. Invece di computare le rotazioni matematicamente a runtime tramite trasformazioni geometriche, ogni tetromino definisce esplicitamente i suoi 4 stati rotazionali come layer di una matrice 3D:

\begin{lstlisting}[language=Java]
/** The 4 rotation states of the T piece. */
private static final int[][][] SHAPES = {
  {{0, 1, 0}, {1, 1, 1}, {0, 0, 0}},
  {{0, 1, 0}, {0, 1, 1}, {0, 1, 0}},
  {{0, 0, 0}, {1, 1, 1}, {0, 1, 0}},
  {{0, 1, 0}, {1, 1, 0}, {0, 1, 0}},
};
\end{lstlisting}

Questo approccio, ispirato al Super Rotation System (SRS) definito nelle Tetris Guideline~\cite{srs}, è lo standard de facto nelle implementazioni del gioco, come documentato anche nella libreria Tetris Gymnasium~\cite{tetrisgym}. La rotazione diventa un semplice cambio di indice nella matrice, eliminando calcoli trigonometrici e casi speciali per pezzi asimmetrici.

Anche le formule per la velocità di caduta dei pezzi sono riprese da fonti ufficiali: la \texttt{ClassicSpeedStrategy} utilizza la tabella frames-per-row del Tetris NES (NTSC, 60 FPS), mentre la \texttt{ModernSpeedStrategy} implementa la formula delle Tetris Guideline: $(0.8 - ((level - 1) \times 0.007))^{level - 1}$.

\chapter{Commenti finali}

\section{Autovalutazione e lavori futuri}

Complessivamente il progetto ha raggiunto gli obiettivi che mi ero prefissato: un clone funzionante di Tetris con un'architettura pulita e manutenibile. Ci sono tuttavia alcuni aspetti dell'implementazione che, col senno di poi, avrei affrontato diversamente.

\textbf{Gestione della GameSession.} La classe \texttt{GameSession} è stata introdotta in una fase avanzata dello sviluppo, quando l'architettura dei controller era già consolidata. Il suo scopo è propagare le informazioni di una partita (punteggio, livello, ultimo frame) tra i diversi stati del gioco, ad esempio da \texttt{PLAYING} a \texttt{GAME\_OVER}. La soluzione funziona, ma risulta un po' rigida: ogni controller deve esplicitamente costruire e restituire una \texttt{GameSession} nel metodo \texttt{exit()}, e riceverla nel metodo \texttt{enter()}. Un approccio alternativo, progettato fin dall'inizio, avrebbe potuto essere un sistema ad eventi: i controller pubblicano eventi (es. \texttt{GameEndedEvent}) e gli interessati si sottoscrivono, disaccoppiando completamente produttori e consumatori di informazioni.

\textbf{Inizializzazione statica dei controller.} Nell'\texttt{ApplicationContext}, i controller vengono istanziati e registrati manualmente nel metodo \texttt{setupGameComponents()}. Ogni nuova coppia stato-controller richiede modifiche in questo punto. Una soluzione più flessibile avrebbe potuto sfruttare annotazioni custom (es. \texttt{@GameState(GameState.MENU)}) e reflection per scoprire automaticamente i controller e associarli ai rispettivi stati nel \texttt{GameStateManager}, seguendo un approccio simile a quello di framework come Spring.

\textbf{Accoppiamento dei colori con AWT.} Nei model dei tetromini il colore è rappresentato direttamente con \texttt{java.awt.Color}, creando una dipendenza dal framework grafico. Per una maggiore portabilità sarebbe stato preferibile utilizzare un enum o un record \texttt{Color(int r, int g, int b)}, lasciando alla view il compito di convertirlo nel tipo specifico del framework.

\textbf{Gestione del nickname.} Nei requisiti iniziali era previsto che il nickname del giocatore fosse richiesto tramite input. Per semplificare l'implementazione e ridurre i tempi di sviluppo, ho optato per la generazione automatica del nickname e la sua persistenza in un file nella home directory dell'utente.

\textbf{Sviluppi futuri.} Se dovessi portare avanti il progetto, oltre a risolvere i punti sopra citati, aggiungerei:
\begin{itemize}
    \item Schermata delle opzioni per configurare modalità di gioco e impostazioni a runtime
    \item Personalizzazione grafica dei tetromini e dello sfondo
    \item Ottimizzazione delle prestazioni e dell'utilizzo della memoria
\end{itemize}

\section{Difficoltà incontrate e commenti per i docenti}

Premetto che la mia situazione non è quella dello studente ``tipo'': sono fuori corso da diversi anni e lavoro a tempo pieno. Questa condizione ha rappresentato la difficoltà principale nello svolgimento del progetto, non tanto per complessità tecniche o lacune nella preparazione, quanto per l'impossibilità di garantire un impegno continuativo nel tempo.

Il lavoro frammentato ha reso più complesso mantenere il filo logico del progetto: a volte le sessioni di sviluppo si concentravano nel fine settimana, seguite da un'intera settimana senza poter toccare il codice. Riprendere il lavoro dopo giorni di pausa significava ogni volta ricostruire mentalmente il contesto: dove ero arrivato, quali decisioni avevo preso e perché, quali erano i prossimi passi. Questo overhead ha inevitabilmente rallentato lo sviluppo e, in alcuni casi, portato a riscrivere parti di codice che con un lavoro più continuo sarebbero state affrontate diversamente fin dall'inizio.

Non intendo con questo cercare giustificazioni o attenuanti: la responsabilità di non aver completato il percorso universitario nei tempi previsti è esclusivamente mia. Tuttavia, ritengo utile condividere questa esperienza perché rappresenta una realtà concreta di chi, per scelte di vita o necessità, si trova a conciliare studio e lavoro. Il corso e il progetto sono stati comunque un'occasione preziosa per consolidare competenze, e per approfondire aspetti della programmazione ad oggetti che nella pratica lavorativa spesso si danno per scontati o si dimentica di applicare.

\appendix

\chapter{Guida utente}

\section{Avvio del gioco}

Per avviare Tetraj è necessario avere Java 21 (o versione successiva)~\cite{adoptium} installato sul proprio sistema. Il gioco si avvia eseguendo il file \texttt{tetraj.jar} con il comando:

\begin{verbatim}
java -jar tetraj.jar
\end{verbatim}

In alternativa, è possibile scaricare l'ultima versione ed eseguire direttamente il gioco con un singolo comando.

\textbf{macOS / Linux (zsh/bash):}
\begin{verbatim}
curl -L https://tinyurl.com/tetrajar -o /tmp/tetraj.jar && \
  java -jar /tmp/tetraj.jar
\end{verbatim}

\textbf{Windows (PowerShell):}
\begin{verbatim}
Invoke-WebRequest -Uri "https://tinyurl.com/tetrajar" `
  -OutFile "$env:TEMP\tetraj.jar"; java -jar "$env:TEMP\tetraj.jar"
\end{verbatim}

\section{Schermata iniziale}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{resources/screenshots/01-MenuView.png}
    \caption{Schermata iniziale del gioco}
    \label{fig:menu-view}
\end{figure}

All'avvio viene mostrato il menu principale. Da qui è possibile:

\begin{itemize}
    \item Premere \textbf{INVIO} per iniziare una nuova partita
    \item Premere \textbf{L} per visualizzare la classifica dei punteggi
    \item Premere \textbf{ESC} per uscire dal gioco
\end{itemize}

\section{Durante la partita}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{resources/screenshots/03-PlayView.png}
    \caption{Schermata di gioco}
    \label{fig:play-view}
\end{figure}

Una volta avviata la partita, sullo schermo sono visibili: l'area di gioco centrale dove cadono i pezzi, il prossimo pezzo in arrivo, l'eventuale pezzo messo da parte, il punteggio, il livello e il numero di linee completate.

I controlli disponibili sono:

\begin{itemize}
    \item \textbf{Freccia sinistra} o \textbf{A}: sposta il pezzo a sinistra
    \item \textbf{Freccia destra} o \textbf{D}: sposta il pezzo a destra
    \item \textbf{Freccia giù} o \textbf{S}: accelera la caduta del pezzo (soft drop)
    \item \textbf{Barra spaziatrice}: fa cadere istantaneamente il pezzo (hard drop)
    \item \textbf{Freccia su} o \textbf{W}: ruota il pezzo in senso orario
    \item \textbf{CTRL} o \textbf{Z}: ruota il pezzo in senso antiorario
    \item \textbf{SHIFT} o \textbf{C}: mette da parte il pezzo corrente per usarlo dopo
    \item \textbf{P}: mette in pausa la partita
    \item \textbf{ESC}: torna al menu principale
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{resources/screenshots/04-PlayViewPaused.png}
    \caption{Schermata di gioco in pausa}
    \label{fig:play-view-paused}
\end{figure}

Durante la pausa, premere \textbf{P} o \textbf{ESC} per riprendere a giocare.

\section{Punteggio}

Il punteggio aumenta completando linee orizzontali. Più linee si completano contemporaneamente, più punti si ottengono:

\begin{itemize}
    \item 1 linea: 100 punti
    \item 2 linee: 300 punti
    \item 3 linee: 500 punti
    \item 4 linee (Tetris): 800 punti
\end{itemize}

I punti vengono moltiplicati per il livello corrente. Inoltre, il soft drop assegna 1 punto bonus per ogni cella percorsa, mentre l'hard drop ne assegna 2 per ogni cella di altezza da cui cade il pezzo.

Il livello aumenta ogni 10 linee completate, rendendo la caduta dei pezzi progressivamente più veloce.

\section{Fine partita e classifica}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{resources/screenshots/05-GameOver.png}
    \caption{Schermata di fine della partita}
    \label{fig:gameover}
\end{figure}

La partita termina quando non c'è più spazio per posizionare un nuovo pezzo. Viene mostrata la schermata di fine partita con il punteggio ottenuto. Da qui è possibile:

\begin{itemize}
    \item Premere \textbf{INVIO} per iniziare una nuova partita
    \item Premere \textbf{L} per visualizzare la classifica
    \item Premere \textbf{ESC} per tornare al menu principale
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{resources/screenshots/02-LeaderboardView.png}
    \caption{Schermata con i dieci punteggi migliori "Block legends"}
    \label{fig:leaderboard}
\end{figure}

Dalla schermata della classifica, premere \textbf{ESC} per tornare al menu.

\chapter{Esercitazioni di laboratorio}

\section*{patrizio.bertozzi@studio.unibo.it}

\begin{itemize}
    \item Laboratorio 07: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=177162#p246015}
    \item Laboratorio 09: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=179154#p247849}
    \item Laboratorio 10: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=180101#p248934}
    \item Laboratorio 11: \url{https://virtuale.unibo.it/mod/forum/discuss.php?d=181206#p251421}
\end{itemize}

\begin{thebibliography}{99}

\bibitem{tetriswiki}
TetrisWiki,
\textit{Enciclopedia della community dedicata al gioco Tetris},
\url{https://tetris.wiki/Tetris.wiki}

\bibitem{tetromino}
TetrisWiki,
\textit{Tetromino -- Descrizione delle forme e dei colori ufficiali dei sette tetromini},
\url{https://tetris.wiki/Tetromino}

\bibitem{mvc}
Wikipedia,
\textit{Pattern Model--view--controller},
\url{https://en.wikipedia.org/wiki/Model-view-controller}

\bibitem{fsm}
Wikipedia,
\textit{Pattern Finite-state machine},
\url{https://en.wikipedia.org/wiki/Finite-state_machine}

\bibitem{servicelocator}
Wikipedia,
\textit{Pattern Service locator},
\url{https://en.wikipedia.org/wiki/Service_locator_pattern}

\bibitem{gameloop}
Wikipedia,
\textit{Game loop},
\url{https://en.wikipedia.org/wiki/Game_loop}

\bibitem{command}
Wikipedia,
\textit{Pattern Command},
\url{https://en.wikipedia.org/wiki/Command_pattern}

\bibitem{strategy}
Wikipedia,
\textit{Pattern Strategy},
\url{https://en.wikipedia.org/wiki/Strategy_pattern}

\bibitem{simplefactory}
Wikipedia,
\textit{Pattern Factory},
\url{https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)}

\bibitem{templatemethod}
Wikipedia,
\textit{Pattern Template Method},
\url{https://en.wikipedia.org/wiki/Template_method_pattern}

\bibitem{fbounded}
Wikipedia,
\textit{Generici -- Bounded quantification, F-bounded quantification},
\url{https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification}

\bibitem{registry}
Martin Fowler,
\textit{Pattern Registry},
\url{https://martinfowler.com/eaaCatalog/registry.html}

\bibitem{singleton}
Wikipedia,
\textit{Pattern Singleton},
\url{https://en.wikipedia.org/wiki/Singleton_pattern}

\bibitem{srs}
TetrisWiki,
\textit{Tetromino -- Super Rotation System},
\url{https://tetris.wiki/Super_Rotation_System}

\bibitem{tetrisgym}
Tetris Gymnasium,
\textit{Tetromino -- Documentazione delle forme e rotazioni},
\url{https://max-we.github.io/Tetris-Gymnasium/components/tetromino/}

\bibitem{adoptium}
Eclipse Adoptium,
\textit{Temurin JDK 21 -- Pagina di download},
\url{https://adoptium.net/temurin/releases?version=21}

\end{thebibliography}

\end{document}
